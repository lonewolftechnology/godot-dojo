/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "controller.hpp"

namespace controller {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 30;
    auto scaffolding_contract_version = ffi_controller_uniffi_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error("UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_func_controller_has_storage() != 40864) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_func_get_controller_class_hash() != 53006) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_func_get_public_key() != 43455) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_func_signer_to_guid() != 46384) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_func_validate_felt() != 45886) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_address() != 26106) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_app_id() != 16856) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id() != 17535) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error() != 4396) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account() != 35092) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect() != 22110) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_error_message() != 10095) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_execute() != 21076) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_signup() != 15081) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain() != 38838) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_transfer() != 14676) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_controlleraccount_username() != 61539) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_address() != 14778) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_app_id() != 33071) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id() != 36850) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_execute() != 42467) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside() != 4484) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at() != 21117) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired() != 37606) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked() != 17252) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid() != 15668) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_session_id() != 35493) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_method_sessionaccount_username() != 22367) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage() != 53452) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_controlleraccount_new() != 11383) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless() != 47497) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_owner_new() != 62973) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe() != 29386) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_controller_uniffi_checksum_constructor_sessionaccount_new() != 5711) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }

    }

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
}

template <typename F>
void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F, typename EF, typename... Args, typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = { 0 };

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

template <typename F, typename W>
void rust_call_trait_interface(RustCallStatus* status, F make_call, W write_value) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        if constexpr(has_return_type) {
            write_value(make_call());
        } else {
            make_call();
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = FfiConverterString::lower(e.what());
    }
}

template <typename E, typename W, typename F, typename EF>
void rust_call_trait_interface_with_error(RustCallStatus* status, F make_call, W write_value, EF error_cb) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        try {
            if constexpr(has_return_type) {
                write_value(make_call());
            } else {
                make_call();
            }
        } catch (E &e) {
            status->code = 1;
            status->error_buf = error_cb(e);
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = FfiConverterString::lower(e.what());
    }
}


RustBuffer rustbuffer_alloc(uint64_t len) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_controller_uniffi_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_controller_uniffi_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = { 0 };

    ffi_controller_uniffi_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}


uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

uint64_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<uint64_t>(sizeof(uint64_t));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

uint64_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes { len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data())) };

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

uint64_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<uint64_t>(sizeof(int32_t) + val.length());
}
} // namespace uniffi








ControllerAccount::ControllerAccount(void *ptr): instance(ptr) {}

ControllerAccount::ControllerAccount(const ControllerAccount &other) : instance(nullptr) {
    if (other.instance) {
        instance = other._uniffi_internal_clone_pointer();
    }
}




std::shared_ptr<ControllerAccount> ControllerAccount::init(const std::string &app_id, const std::string &username, const ControllerFieldElement &class_hash, const std::string &rpc_url, const std::shared_ptr<Owner> &owner, const ControllerFieldElement &address, const ControllerFieldElement &chain_id) {
    return std::shared_ptr<ControllerAccount>(
        new ControllerAccount(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_controlleraccount_new,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(app_id), uniffi::FfiConverterString::lower(username), uniffi::FfiConverterTypeControllerFieldElement::lower(class_hash), uniffi::FfiConverterString::lower(rpc_url), uniffi::FfiConverterOwner::lower(owner), uniffi::FfiConverterTypeControllerFieldElement::lower(address), uniffi::FfiConverterTypeControllerFieldElement::lower(chain_id)))
    );
}

std::shared_ptr<ControllerAccount> ControllerAccount::from_storage(const std::string &app_id) {
    return std::shared_ptr<ControllerAccount>(new ControllerAccount(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(app_id))));
}

std::shared_ptr<ControllerAccount> ControllerAccount::new_headless(const std::string &app_id, const std::string &username, const ControllerFieldElement &class_hash, const std::string &rpc_url, const std::shared_ptr<Owner> &owner, const ControllerFieldElement &chain_id) {
    return std::shared_ptr<ControllerAccount>(new ControllerAccount(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(app_id), uniffi::FfiConverterString::lower(username), uniffi::FfiConverterTypeControllerFieldElement::lower(class_hash), uniffi::FfiConverterString::lower(rpc_url), uniffi::FfiConverterOwner::lower(owner), uniffi::FfiConverterTypeControllerFieldElement::lower(chain_id))));
}

ControllerFieldElement ControllerAccount::address() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_address,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}
std::string ControllerAccount::app_id() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_app_id,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}
ControllerFieldElement ControllerAccount::chain_id() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_chain_id,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}
void ControllerAccount::clear_last_error() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error,
        nullptr,
        ptr);
}
ControllerFieldElement ControllerAccount::delegate_account() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}
void ControllerAccount::disconnect() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_disconnect,
        uniffi::FfiConverterControllerError::lift,
        ptr);
}
std::string ControllerAccount::error_message() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_error_message,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}
ControllerFieldElement ControllerAccount::execute(const std::vector<std::shared_ptr<Call>> &calls) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_execute,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterSequenceTypeCall::lower(calls)));
}
void ControllerAccount::signup(const SignerType &signer_type, std::optional<uint64_t> session_expiration, std::optional<std::string> cartridge_api_url) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_signup,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterSignerType::lower(signer_type), uniffi::FfiConverterOptionalUInt64::lower(session_expiration), uniffi::FfiConverterOptionalString::lower(cartridge_api_url));
}
void ControllerAccount::switch_chain(const std::string &rpc_url) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterString::lower(rpc_url));
}
ControllerFieldElement ControllerAccount::transfer(const ControllerFieldElement &recipient, const ControllerFieldElement &amount) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_transfer,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterTypeControllerFieldElement::lower(recipient), uniffi::FfiConverterTypeControllerFieldElement::lower(amount)));
}
std::string ControllerAccount::username() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_controlleraccount_username,
        uniffi::FfiConverterControllerError::lift,
        ptr));
}

ControllerAccount::~ControllerAccount() {
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_free_controlleraccount,
        nullptr,
        this->instance
    );
}

void *ControllerAccount::_uniffi_internal_clone_pointer() const {
    return uniffi::rust_call(
        uniffi_controller_uniffi_fn_clone_controlleraccount,
        nullptr,
        this->instance
    );
}




Owner::Owner(void *ptr): instance(ptr) {}

Owner::Owner(const Owner &other) : instance(nullptr) {
    if (other.instance) {
        instance = other._uniffi_internal_clone_pointer();
    }
}




std::shared_ptr<Owner> Owner::init(const std::string &private_key) {
    return std::shared_ptr<Owner>(
        new Owner(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_owner_new,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(private_key)))
    );
}


Owner::~Owner() {
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_free_owner,
        nullptr,
        this->instance
    );
}

void *Owner::_uniffi_internal_clone_pointer() const {
    return uniffi::rust_call(
        uniffi_controller_uniffi_fn_clone_owner,
        nullptr,
        this->instance
    );
}




SessionAccount::SessionAccount(void *ptr): instance(ptr) {}

SessionAccount::SessionAccount(const SessionAccount &other) : instance(nullptr) {
    if (other.instance) {
        instance = other._uniffi_internal_clone_pointer();
    }
}




std::shared_ptr<SessionAccount> SessionAccount::init(const std::string &rpc_url, const std::string &private_key, const ControllerFieldElement &address, const ControllerFieldElement &owner_guid, const ControllerFieldElement &chain_id, const SessionPolicies &policies, uint64_t session_expiration) {
    return std::shared_ptr<SessionAccount>(
        new SessionAccount(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_sessionaccount_new,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(rpc_url), uniffi::FfiConverterString::lower(private_key), uniffi::FfiConverterTypeControllerFieldElement::lower(address), uniffi::FfiConverterTypeControllerFieldElement::lower(owner_guid), uniffi::FfiConverterTypeControllerFieldElement::lower(chain_id), uniffi::FfiConverterTypeSessionPolicies::lower(policies), uniffi::FfiConverterUInt64::lower(session_expiration)))
    );
}

std::shared_ptr<SessionAccount> SessionAccount::create_from_subscribe(const std::string &private_key, const SessionPolicies &policies, const std::string &rpc_url, const std::string &cartridge_api_url) {
    return std::shared_ptr<SessionAccount>(new SessionAccount(uniffi::rust_call(
        uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(private_key), uniffi::FfiConverterTypeSessionPolicies::lower(policies), uniffi::FfiConverterString::lower(rpc_url), uniffi::FfiConverterString::lower(cartridge_api_url))));
}

std::string SessionAccount::address() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_address,
        nullptr,
        ptr));
}
std::optional<std::string> SessionAccount::app_id() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterOptionalString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_app_id,
        nullptr,
        ptr));
}
std::string SessionAccount::chain_id() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_chain_id,
        nullptr,
        ptr));
}
ControllerFieldElement SessionAccount::execute(const std::vector<std::shared_ptr<Call>> &calls) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_execute,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterSequenceTypeCall::lower(calls)));
}
ControllerFieldElement SessionAccount::execute_from_outside(const std::vector<std::shared_ptr<Call>> &calls) {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterTypeControllerFieldElement::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside,
        uniffi::FfiConverterControllerError::lift,
        ptr, uniffi::FfiConverterSequenceTypeCall::lower(calls)));
}
uint64_t SessionAccount::expires_at() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_expires_at,
        nullptr,
        ptr));
}
bool SessionAccount::is_expired() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_is_expired,
        nullptr,
        ptr));
}
bool SessionAccount::is_revoked() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked,
        nullptr,
        ptr));
}
std::string SessionAccount::owner_guid() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid,
        nullptr,
        ptr));
}
std::optional<std::string> SessionAccount::session_id() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterOptionalString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_session_id,
        nullptr,
        ptr));
}
std::optional<std::string> SessionAccount::username() {
    auto ptr = this->_uniffi_internal_clone_pointer();
    return uniffi::FfiConverterOptionalString::lift(uniffi::rust_call(
        uniffi_controller_uniffi_fn_method_sessionaccount_username,
        nullptr,
        ptr));
}

SessionAccount::~SessionAccount() {
    uniffi::rust_call(
        uniffi_controller_uniffi_fn_free_sessionaccount,
        nullptr,
        this->instance
    );
}

void *SessionAccount::_uniffi_internal_clone_pointer() const {
    return uniffi::rust_call(
        uniffi_controller_uniffi_fn_clone_sessionaccount,
        nullptr,
        this->instance
    );
}













namespace uniffi {





std::shared_ptr<ControllerAccount> FfiConverterControllerAccount::lift(void *ptr) {
    return std::shared_ptr<ControllerAccount>(new ControllerAccount(ptr));
}

void *FfiConverterControllerAccount::lower(const std::shared_ptr<ControllerAccount> &obj) {
    return reinterpret_cast<ControllerAccount*>(obj.get())->_uniffi_internal_clone_pointer();
}

std::shared_ptr<ControllerAccount> FfiConverterControllerAccount::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return FfiConverterControllerAccount::lift(reinterpret_cast<void *>(ptr));
}

void FfiConverterControllerAccount::write(RustStream &stream, const std::shared_ptr<ControllerAccount> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(FfiConverterControllerAccount::lower(obj));
}

uint64_t FfiConverterControllerAccount::allocation_size(const std::shared_ptr<ControllerAccount> &) {
    return 8;
}



std::shared_ptr<Owner> FfiConverterOwner::lift(void *ptr) {
    return std::shared_ptr<Owner>(new Owner(ptr));
}

void *FfiConverterOwner::lower(const std::shared_ptr<Owner> &obj) {
    return reinterpret_cast<Owner*>(obj.get())->_uniffi_internal_clone_pointer();
}

std::shared_ptr<Owner> FfiConverterOwner::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return FfiConverterOwner::lift(reinterpret_cast<void *>(ptr));
}

void FfiConverterOwner::write(RustStream &stream, const std::shared_ptr<Owner> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(FfiConverterOwner::lower(obj));
}

uint64_t FfiConverterOwner::allocation_size(const std::shared_ptr<Owner> &) {
    return 8;
}



std::shared_ptr<SessionAccount> FfiConverterSessionAccount::lift(void *ptr) {
    return std::shared_ptr<SessionAccount>(new SessionAccount(ptr));
}

void *FfiConverterSessionAccount::lower(const std::shared_ptr<SessionAccount> &obj) {
    return reinterpret_cast<SessionAccount*>(obj.get())->_uniffi_internal_clone_pointer();
}

std::shared_ptr<SessionAccount> FfiConverterSessionAccount::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return FfiConverterSessionAccount::lift(reinterpret_cast<void *>(ptr));
}

void FfiConverterSessionAccount::write(RustStream &stream, const std::shared_ptr<SessionAccount> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(FfiConverterSessionAccount::lower(obj));
}

uint64_t FfiConverterSessionAccount::allocation_size(const std::shared_ptr<SessionAccount> &) {
    return 8;
}


Call FfiConverterTypeCall::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCall::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCall::lower(const Call &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCall::write(stream, val);

    return std::move(buf);
}

Call FfiConverterTypeCall::read(RustStream &stream) {
    return {
        FfiConverterTypeControllerFieldElement::read(stream),
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeControllerFieldElement::read(stream)
    };
}

void FfiConverterTypeCall::write(RustStream &stream, const Call &val) {
    FfiConverterTypeControllerFieldElement::write(stream, val.contract_address);
    FfiConverterString::write(stream, val.entrypoint);
    FfiConverterSequenceTypeControllerFieldElement::write(stream, val.calldata);
}

uint64_t FfiConverterTypeCall::allocation_size(const Call &val) {
    
    return 
        FfiConverterTypeControllerFieldElement::allocation_size(val.contract_address) +
        FfiConverterString::allocation_size(val.entrypoint) +
        FfiConverterSequenceTypeControllerFieldElement::allocation_size(val.calldata);
    
}


SessionPolicies FfiConverterTypeSessionPolicies::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSessionPolicies::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSessionPolicies::lower(const SessionPolicies &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSessionPolicies::write(stream, val);

    return std::move(buf);
}

SessionPolicies FfiConverterTypeSessionPolicies::read(RustStream &stream) {
    return {
        FfiConverterSequenceTypeSessionPolicy::read(stream),
        FfiConverterTypeControllerFieldElement::read(stream)
    };
}

void FfiConverterTypeSessionPolicies::write(RustStream &stream, const SessionPolicies &val) {
    FfiConverterSequenceTypeSessionPolicy::write(stream, val.policies);
    FfiConverterTypeControllerFieldElement::write(stream, val.max_fee);
}

uint64_t FfiConverterTypeSessionPolicies::allocation_size(const SessionPolicies &val) {
    
    return 
        FfiConverterSequenceTypeSessionPolicy::allocation_size(val.policies) +
        FfiConverterTypeControllerFieldElement::allocation_size(val.max_fee);
    
}


SessionPolicy FfiConverterTypeSessionPolicy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSessionPolicy::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSessionPolicy::lower(const SessionPolicy &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSessionPolicy::write(stream, val);

    return std::move(buf);
}

SessionPolicy FfiConverterTypeSessionPolicy::read(RustStream &stream) {
    return {
        FfiConverterTypeControllerFieldElement::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeSessionPolicy::write(RustStream &stream, const SessionPolicy &val) {
    FfiConverterTypeControllerFieldElement::write(stream, val.contract_address);
    FfiConverterString::write(stream, val.entrypoint);
}

uint64_t FfiConverterTypeSessionPolicy::allocation_size(const SessionPolicy &val) {
    
    return 
        FfiConverterTypeControllerFieldElement::allocation_size(val.contract_address) +
        FfiConverterString::allocation_size(val.entrypoint);
    
}


std::shared_ptr<ControllerError> FfiConverterControllerError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterControllerError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterControllerError::lower(const ControllerError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterControllerError::write(stream, val);

    return std::move(buf);
}

std::shared_ptr<ControllerError> FfiConverterControllerError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1:
        return std::make_shared<controller_error::InitializationError>(FfiConverterString::read(stream));
    
    case 2:
        return std::make_shared<controller_error::SignupError>(FfiConverterString::read(stream));
    
    case 3:
        return std::make_shared<controller_error::ExecutionError>(FfiConverterString::read(stream));
    
    case 4:
        return std::make_shared<controller_error::NetworkError>(FfiConverterString::read(stream));
    
    case 5:
        return std::make_shared<controller_error::StorageError>(FfiConverterString::read(stream));
    
    case 6:
        return std::make_shared<controller_error::InvalidInput>(FfiConverterString::read(stream));
    
    case 7:
        return std::make_shared<controller_error::DisconnectError>(FfiConverterString::read(stream));
    
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterControllerError::write(RustStream &stream, const ControllerError &val) {
    stream << val.get_variant_idx();
    FfiConverterString::write(stream, val.what());
}

uint64_t FfiConverterControllerError::allocation_size(const ControllerError &val) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


SignerType FfiConverterSignerType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterSignerType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterSignerType::lower(const SignerType &val) {
    auto buf = rustbuffer_alloc(FfiConverterSignerType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterSignerType::write(stream, val);

    return std::move(buf);
}

SignerType FfiConverterSignerType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return SignerType::kWebauthn;
        
    case 2:
        return SignerType::kStarknet;
        
    default:
        throw std::runtime_error("No matching SignerType variant");
    }
}

void FfiConverterSignerType::write(RustStream &stream, const SignerType &val) {
    switch (val) {
        
    case SignerType::kWebauthn:
        stream << static_cast<int32_t>(1);
        break;
        
    case SignerType::kStarknet:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching SignerType variant");
    }
}

uint64_t FfiConverterSignerType::allocation_size(const SignerType &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}


Version FfiConverterVersion::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterVersion::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterVersion::lower(const Version &val) {
    auto buf = rustbuffer_alloc(FfiConverterVersion::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterVersion::write(stream, val);

    return std::move(buf);
}

Version FfiConverterVersion::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return Version::kV104;
        
    case 2:
        return Version::kV105;
        
    case 3:
        return Version::kV106;
        
    case 4:
        return Version::kV107;
        
    case 5:
        return Version::kV108;
        
    case 6:
        return Version::kV109;
        
    case 7:
        return Version::kLatest;
        
    default:
        throw std::runtime_error("No matching Version variant");
    }
}

void FfiConverterVersion::write(RustStream &stream, const Version &val) {
    switch (val) {
        
    case Version::kV104:
        stream << static_cast<int32_t>(1);
        break;
        
    case Version::kV105:
        stream << static_cast<int32_t>(2);
        break;
        
    case Version::kV106:
        stream << static_cast<int32_t>(3);
        break;
        
    case Version::kV107:
        stream << static_cast<int32_t>(4);
        break;
        
    case Version::kV108:
        stream << static_cast<int32_t>(5);
        break;
        
    case Version::kV109:
        stream << static_cast<int32_t>(6);
        break;
        
    case Version::kLatest:
        stream << static_cast<int32_t>(7);
        break;
        
    default:
        throw std::runtime_error("No matching Version variant");
    }
}

uint64_t FfiConverterVersion::allocation_size(const Version &) {
    return static_cast<uint64_t>(sizeof(int32_t));
}

std::optional<uint64_t> FfiConverterOptionalUInt64::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalUInt64::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalUInt64::lower(const std::optional<uint64_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalUInt64::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalUInt64::write(stream, val);

    return buf;
}

std::optional<uint64_t> FfiConverterOptionalUInt64::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterUInt64::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalUInt64::write(RustStream &stream, const std::optional<uint64_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterUInt64::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalUInt64::allocation_size(const std::optional<uint64_t> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterUInt64::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::string> FfiConverterOptionalString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalString::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalString::lower(const std::optional<std::string>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalString::write(stream, val);

    return buf;
}

std::optional<std::string> FfiConverterOptionalString::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterString::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalString::write(RustStream &stream, const std::optional<std::string>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterString::write(stream, value.value());
    }
}

uint64_t FfiConverterOptionalString::allocation_size(const std::optional<std::string> &val) {
    uint64_t ret = 1;

    if (val) {
        ret += FfiConverterString::allocation_size(val.value());
    }

    return ret;
}


std::vector<std::shared_ptr<Call>> FfiConverterSequenceTypeCall::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeCall::lower(const std::vector<std::shared_ptr<Call>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<Call>> FfiConverterSequenceTypeCall::read(RustStream &stream) {
    std::vector<std::shared_ptr<Call>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<Call>(FfiConverterTypeCall::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeCall::write(RustStream &stream, const std::vector<std::shared_ptr<Call>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeCall::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeCall::allocation_size(const std::vector<std::shared_ptr<Call>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeCall::allocation_size(*elem);
    }

    return size;
}


std::vector<std::shared_ptr<SessionPolicy>> FfiConverterSequenceTypeSessionPolicy::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSessionPolicy::lower(const std::vector<std::shared_ptr<SessionPolicy>> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::shared_ptr<SessionPolicy>> FfiConverterSequenceTypeSessionPolicy::read(RustStream &stream) {
    std::vector<std::shared_ptr<SessionPolicy>> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(std::make_shared<SessionPolicy>(FfiConverterTypeSessionPolicy::read(stream)));
    }

    return ret;
}

void FfiConverterSequenceTypeSessionPolicy::write(RustStream &stream, const std::vector<std::shared_ptr<SessionPolicy>> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSessionPolicy::write(stream, *elem);
    }
}

uint64_t FfiConverterSequenceTypeSessionPolicy::allocation_size(const std::vector<std::shared_ptr<SessionPolicy>> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSessionPolicy::allocation_size(*elem);
    }

    return size;
}


std::vector<ControllerFieldElement> FfiConverterSequenceTypeControllerFieldElement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeControllerFieldElement::lower(const std::vector<ControllerFieldElement> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ControllerFieldElement> FfiConverterSequenceTypeControllerFieldElement::read(RustStream &stream) {
    std::vector<ControllerFieldElement> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeControllerFieldElement::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeControllerFieldElement::write(RustStream &stream, const std::vector<ControllerFieldElement> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeControllerFieldElement::write(stream, elem);
    }
}

uint64_t FfiConverterSequenceTypeControllerFieldElement::allocation_size(const std::vector<ControllerFieldElement> &val) {
    uint64_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeControllerFieldElement::allocation_size(elem);
    }

    return size;
}


}

bool controller_has_storage(const std::string &app_id) {
    auto ret = uniffi::rust_call(
        uniffi_controller_uniffi_fn_func_controller_has_storage,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(app_id));

    return uniffi::FfiConverterBool::lift(ret);
}


ControllerFieldElement get_controller_class_hash(const Version &version) {
    auto ret = uniffi::rust_call(
        uniffi_controller_uniffi_fn_func_get_controller_class_hash,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterVersion::lower(version));

    return uniffi::FfiConverterTypeControllerFieldElement::lift(ret);
}


ControllerFieldElement get_public_key(const ControllerFieldElement &private_key) {
    auto ret = uniffi::rust_call(
        uniffi_controller_uniffi_fn_func_get_public_key,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterTypeControllerFieldElement::lower(private_key));

    return uniffi::FfiConverterTypeControllerFieldElement::lift(ret);
}


ControllerFieldElement signer_to_guid(const ControllerFieldElement &private_key) {
    auto ret = uniffi::rust_call(
        uniffi_controller_uniffi_fn_func_signer_to_guid,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterTypeControllerFieldElement::lower(private_key));

    return uniffi::FfiConverterTypeControllerFieldElement::lift(ret);
}


bool validate_felt(const std::string &felt) {
    auto ret = uniffi::rust_call(
        uniffi_controller_uniffi_fn_func_validate_felt,
        uniffi::FfiConverterControllerError::lift, uniffi::FfiConverterString::lower(felt));

    return uniffi::FfiConverterBool::lift(ret);
}
} // namespace controller